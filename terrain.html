<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Simple Walkable Terrain</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      pointer-events: none; color: white; font-family: system-ui, sans-serif;
      text-shadow: 0 2px 8px rgba(0,0,0,.6); padding: 16px;
    }
    #hint {
      pointer-events: auto; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.2);
      border-radius: 12px; padding: 14px 18px; line-height: 1.45; max-width: 680px; text-align: center;
    }
    kbd {
      background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.25);
      border-bottom-width: 3px; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    #seedLabel {
      position: fixed; left: 10px; bottom: 10px; color: #ddd; font: 12px/1.2 system-ui, sans-serif;
      background: rgba(0,0,0,.35); padding: 6px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,.15);
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="hint">
      <div style="font-size:22px; font-weight:700; margin-bottom:6px;">Simple HTML Terrain â€” Walk Around</div>
      <div>Click to enter, then move with <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd>, look with the mouse, jump with <kbd>Space</kbd>, sprint with <kbd>Shift</kbd>. Press <kbd>R</kbd> to regenerate terrain.</div>
    </div>
  </div>
  <div id="seedLabel"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/PointerLockControls.js";

    // ---------- Config ----------
    const WORLD_SIZE = 1200;        // meters across (square)
    const RESOLUTION = 256;         // segments per side (terrain detail)
    const MAX_ELEVATION = 85;       // meters
    const EYE_HEIGHT = 1.8;         // player's eye height above ground
    const GRAVITY = 28;             // m/s^2 downward
    const WALK_SPEED = 12;          // m/s
    const SPRINT_MULT = 1.8;        // sprint multiplier
    const FRICTION = 8;             // horizontal damping
    const JUMP_VELOCITY = 9;        // m/s
    const SKY_COLOR = 0x87b6ff;
    const FOG_DIST = WORLD_SIZE * 0.85;

    // ---------- Seeded RNG + Perlin (2D) ----------
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function makePerlin2D(seed = 12345) {
      const rand = mulberry32(seed);
      const p = new Uint8Array(512);
      const perm = new Uint8Array(256);
      for (let i = 0; i < 256; i++) perm[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = (rand() * (i + 1)) | 0;
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 512; i++) p[i] = perm[i & 255];

      const fade = t => t*t*t*(t*(t*6 - 15) + 10);
      const lerp = (a, b, t) => a + t * (b - a);
      const grad = (hash, x, y) => {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      };

      function noise(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const aa = p[p[X] + Y], ab = p[p[X] + Y + 1];
        const ba = p[p[X + 1] + Y], bb = p[p[X + 1] + Y + 1];
        return lerp(
          lerp(grad(aa, x, y), grad(ba, x - 1, y), u),
          lerp(grad(ab, x, y - 1), grad(bb, x - 1, y - 1), u),
          v
        );
      }

      // Fractal Brownian Motion (fbm)
      function fbm(x, y, octaves = 5, lacunarity = 2.0, gain = 0.5) {
        let amp = 0.5, freq = 1.0, sum = 0.0, norm = 0.0;
        for (let i = 0; i < octaves; i++) {
          sum += amp * noise(x * freq, y * freq);
          norm += amp;
          amp *= gain;
          freq *= lacunarity;
        }
        return sum / norm; // -1..1
      }

      return { noise, fbm };
    }

    // ---------- World / Terrain ----------
    let scene, camera, renderer, controls, terrainMesh, clock, seed, rng, perlin;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const move = { forward:false, back:false, left:false, right:false, sprint:false };
    let canJump = false;

    init();
    generateWorld();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(SKY_COLOR);
      scene.fog = new THREE.Fog(SKY_COLOR, 40, FOG_DIST);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 5000);
      camera.position.set(0, 40, 0);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      controls = new PointerLockControls(camera, renderer.domElement);
      controls.addEventListener('lock', () => document.getElementById('overlay').style.display = 'none');
      controls.addEventListener('unlock', () => document.getElementById('overlay').style.display = '');
      document.getElementById('overlay').addEventListener('click', () => controls.lock());

      // Lighting
      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(0.4, 1, 0.2).multiplyScalar(500);
      scene.add(sun);
      scene.add(new THREE.AmbientLight(0xffffff, 0.45));

      // Gentle sky hemisphere tint (optional visual)
      const hemi = new THREE.HemisphereLight(0xbcd4ff, 0x224422, 0.15);
      scene.add(hemi);

      clock = new THREE.Clock();

      // Input
      const onKey = (e, down) => {
        switch (e.code) {
          case 'KeyW': move.forward = down; break;
          case 'KeyS': move.back = down; break;
          case 'KeyA': move.left = down; break;
          case 'KeyD': move.right = down; break;
          case 'ShiftLeft': case 'ShiftRight': move.sprint = down; break;
          case 'Space':
            if (down && canJump) { velocity.y = JUMP_VELOCITY; canJump = false; }
            break;
          case 'KeyR':
            if (down) regenerate();
            break;
        }
      };
      window.addEventListener('keydown', e => onKey(e, true));
      window.addEventListener('keyup', e => onKey(e, false));
      window.addEventListener('resize', onResize);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function regenerate() {
      // New seed & terrain remesh
      seed = (Math.random() * 1e9) | 0;
      rng = mulberry32(seed);
      perlin = makePerlin2D(seed);
      updateSeedLabel();
      buildTerrainMesh();
      // Move player to a safe starting spot
      const x = 0, z = 0;
      camera.position.set(x, sampleHeight(x, z) + EYE_HEIGHT + 0.1, z);
      velocity.set(0, 0, 0);
      canJump = true;
    }

    function updateSeedLabel() {
      const el = document.getElementById('seedLabel');
      el.textContent = `Seed: ${seed}`;
    }

    function generateWorld() {
      regenerate();
    }

    // Height function: editable terrain style
    function sampleHeight(x, z) {
      // Convert world meters to noise space
      const scale = 0.0023; // lower = larger features
      const base = perlin.fbm(x * scale, z * scale, 5, 2.05, 0.5); // -1..1
      // Add ridges/detail
      const ridges = Math.abs(perlin.fbm(x * scale * 1.9, z * scale * 1.9, 3, 2.3, 0.55));
      // Elevation shape (island-style falloff towards edges)
      const d = Math.hypot(x, z) / (WORLD_SIZE * 0.6);
      const falloff = THREE.MathUtils.clamp(1.0 - d * d, 0, 1);
      const h = (base * 0.6 + ridges * 0.5) * MAX_ELEVATION * falloff;
      return h;
    }

    // Build or rebuild the terrain mesh
    function buildTerrainMesh() {
      if (terrainMesh) {
        scene.remove(terrainMesh);
        terrainMesh.geometry.dispose();
        terrainMesh.material.dispose();
      }
      const geom = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, RESOLUTION, RESOLUTION);
      geom.rotateX(-Math.PI / 2);

      // Paint heights & vertex colors
      const pos = geom.attributes.position;
      const colors = new Float32Array((RESOLUTION + 1) * (RESOLUTION + 1) * 3);
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const y = sampleHeight(x, z);
        pos.setY(i, y);

        // Simple biome coloring by altitude
        const n = y / MAX_ELEVATION;
        let r, g, b;
        if (n < 0.08)       { r = 0.10; g = 0.25; b = 0.65; } // water
        else if (n < 0.18)  { r = 0.90; g = 0.85; b = 0.55; } // beach
        else if (n < 0.55)  { r = 0.20; g = 0.55; b = 0.25; } // grass
        else if (n < 0.8)   { r = 0.45; g = 0.40; b = 0.35; } // rock
        else                { r = 0.92; g = 0.95; b = 0.98; } // snow
        colors[i*3+0] = r; colors[i*3+1] = g; colors[i*3+2] = b;
      }
      geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geom.computeVertexNormals();

      const mat = new THREE.MeshStandardMaterial({
        vertexColors: true,
        flatShading: false,
        roughness: 0.95,
        metalness: 0.0
      });

      terrainMesh = new THREE.Mesh(geom, mat);
      terrainMesh.receiveShadow = true;
      scene.add(terrainMesh);
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      // Movement (only when pointer is locked)
      if (controls.isLocked) {
        // Dampen horizontal velocity
        velocity.x -= velocity.x * Math.min(1, FRICTION * dt);
        velocity.z -= velocity.z * Math.min(1, FRICTION * dt);
        // Apply gravity
        velocity.y -= GRAVITY * dt;

        // Determine intended direction
        direction.set(0,0,0);
        if (move.forward) direction.z -= 1;
        if (move.back)    direction.z += 1;
        if (move.left)    direction.x -= 1;
        if (move.right)   direction.x += 1;
        if (direction.lengthSq() > 0) direction.normalize();

        // Move relative to camera orientation (yaw only)
        const speed = WALK_SPEED * (move.sprint ? SPRINT_MULT : 1.0);
        const yaw = controls.getObject().rotation.y;
        const sin = Math.sin(yaw), cos = Math.cos(yaw);
        const dx = (direction.x * cos - direction.z * sin) * speed * dt;
        const dz = (direction.x * sin + direction.z * cos) * speed * dt;
        velocity.x += dx * 10 * dt; // accelerate toward desired
        velocity.z += dz * 10 * dt;

        // Apply movement
        const obj = controls.getObject();
        obj.position.x += velocity.x * dt;
        obj.position.z += velocity.z * dt;
        obj.position.y += velocity.y * dt;

        // Ground collision: stick to terrain, permit jump when grounded
        const groundY = sampleHeight(obj.position.x, obj.position.z) + EYE_HEIGHT;
        if (obj.position.y < groundY) {
          obj.position.y = groundY;
          velocity.y = 0;
          canJump = true;
        }

        // Keep within world bounds (soft clamp)
        const half = WORLD_SIZE * 0.48;
        obj.position.x = THREE.MathUtils.clamp(obj.position.x, -half, half);
        obj.position.z = THREE.MathUtils.clamp(obj.position.z, -half, half);
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
